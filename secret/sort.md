# 插入排序优于选择和冒泡的地方
时间复杂度同样都是O（n^2），这是最坏情况下的时间复杂度

- 但是选择和冒泡与数据形式无关，最好最坏情况都是On
- 插入和数据形式有关，最好情况下（数据有序）O（1） 最坏情况下（倒序） O（n^2）


# 排序的稳定性

可以做到稳定性：

- 冒泡、选择
- 归并

做不到稳定性：

- 插入
- 快排、堆排

> 为什么？
> 只要是跨多个数swap的，很大概率做不到稳定性（我不敢说全部）



# 总结

|     | 时间复杂度    | 空间复杂度   | 稳定性 |
|-----|----------|---------|-----|
| 选择  | O(n2)    | O(1)    | 0   |
| 冒泡  | O(n2)    | O(1)    | 1   |
| 插入  | O(n2)    | O(1)    | 1   |
| 归并  | O(nlogn) | O(n)    | 1   |
| 快排  | O(nlogn) | O(logn) | 0   |
| 堆排  | O(nlogn) | O(1)    | 0   |



优势：
- 归并： 稳定
- 快排： 经验证最快
- 堆排： 空间1

暂时没有时间复杂度小于nlogn的基于比较的排序

暂时稳定的算法中归并的时间空间复杂度最低

归并 '内部缓存法' 可以使空间复杂度变成o（1）但是会失去稳定性

归并 '原地归并排序' 可以使空间复杂度变成o（1）但是空间复杂度会变成o（n2）

快排 可以实现稳定性，但是会使空间复杂度变成o（n）

# 工程上对排序的优化

- 大范围调度用快排，数据量小于一定程度时用插入
- Arrays.sort 中，数据类型为基本数据类型，用快排，引用数据类型，用归并。为什么？稳定性





